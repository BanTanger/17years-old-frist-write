#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;

#define Max 20    //表示最大的棋盘边长,可以自定义为其它数据
int pos[Max + 1];   //为什么只需要定义一个一维数组就能描述二维的棋盘？
                  //pos[i]是这样定义的：即第i列的皇后放在第pos[i]行上，
                  // 也就是说，pos[i]的索引i代表皇后所在的列，它的值pos[i]代表皇后所在的行
int n;          //棋盘的边长和皇后的数量
int sum;         //可以成功摆放的数量，每次遍历成功就加1

bool checkNQ(int col) {      //对第col之前的列进行逐列检查,pos[i]中i的值为列，pos[i]的值为行
    for (int i = 1; i < col; i++)
        if (pos[i] == pos[col] || abs(i - col) == abs(pos[i] - pos[col]))
            //如果行数相同，或者行数相减的绝对值等于列数相减的绝对值（对称轴）
                            //此时都不能放皇后，因为对第col列之前的列进行逐列检查，
                                   //所以不需要再进行列是否相同的判断
            return false;
    return true;
}

void dfsNQ(int col, int n) {
    if (col == n + 1)   //成功遍历一次,sum加1，然后继续探索其他情况
        sum++;
    for (int i = 1; i <= n; i++) {
        pos[col] = i;//假设第col列的皇后放在第i行上，然后利用checkNQ()函数检查是否能放入
                    //第一种情况，如果能放入，则继续假设下一列也放在第i行（实际上第i行此时已经不能放了，
                     //所以cheakNQ()函数就会直接返回false,
                    //然后上面的for循环中的i自动加1,即假设第col+1列放在第i+1行，然后又继续检查能否放入。
                    //第二种情况，如果不能放入，for循环中的i就自动加1，即假设第col列的皇后放在第i+1行上，
                    //又继续检查能否放入
                    //如果当col<=n时（即列还没有遍历完）再也不能在任何一行放皇后，那么此时dfsNQ中的for循环的i已经
                     //遍历完，dfsNQ就会返回到上一级的dfsNQ(col+1,n),此时col就会自动减1（因为每次递归都是加1），
                     //然后，尝试第col列的皇后能否放在第i+1行上，如此进行回溯。
        if (checkNQ(col))
            dfsNQ(col + 1, n);  //进行递归
    }
}
int main()
{
    cout << "请输入皇后的数量：";
    cin >> n;
    dfsNQ(1, n);  //传入第一列和n,从第一列开始放皇后。
    cout << endl << "满足条件的所有摆放次数为：";
    cout << sum;
    return 0;    //说明：dfsNQ函数完全退出的条件是所有满足条件的情况都已经遍历过，再也没有满足条件的遍历
                 //根据递归的初始化分析得知，前面的遍历都会默认第一行第一列的位置会放皇后，
                 //然而实际情况是这个位置不放皇后也能满足条件的次数甚至更多，那么程序在运行到什么时候会把
                 //第一行第一列的位置放空呢？答案是当第一行第一列放皇后的满足条件的所有遍历都结束时，
                //就会把第一列的皇后放在第二行，而把第一行第一列的位置放空。
                 //如此进行到最后，最后面是把第一列的皇后放在最后一行，
                 //然后再全部遍历，结束时整个dfsNQ函数递归运行结束。主函数return 0.
}
